<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:,">
		<title>Proyecto Alquimista</title>
		<style>
			html, body {
				margin: 0;
				height: 100%;
				overflow: hidden;
				background: #0b0e13;
				color: #e6e6e6;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
			}
			#ui {
				position: fixed;
				top: 12px;
				left: 12px;
				background: rgba(0, 0, 0, 0.45);
				backdrop-filter: blur(4px);
				border: 1px solid rgba(255, 255, 255, 0.12);
				padding: 10px 12px;
				border-radius: 10px;
				line-height: 1.35;
				z-index: 10;
				user-select: none;
			}
			#ui b { color: #79ffe1; }
			#hint {
				position: fixed;
				bottom: 12px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.5);
				padding: 8px 12px;
				border-radius: 8px;
				font-size: 14px;
				border: 1px solid rgba(255,255,255,0.1);
			}
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="ui">
			<div><b>Movimiento:</b> W/A/S/D o Flechas Â· Shift para correr</div>
			<div><b>CÃ¡mara 3Âª persona:</b> J/K girar cÃ¡mara Â· U/I zoom</div>
			<div><b>CÃ¡mara cenital:</b> Tecla C para alternar</div>
			<div><b>Acciones:</b> E recoger (cerca de cristal/seta) Â· F soltar en el caldero</div>
			<div><b>Consejos:</b> AcÃ©rcate a los objetos (~1.5m) y al caldero (~2.2m)</div>
			<div id="status">Cargando escenarioâ€¦</div>
			<div style="margin-top:6px; display:flex; align-items:center; gap:8px;">
				<button id="musicToggle" style="padding:4px 8px;">ðŸ”Š MÃºsica</button>
				<label style="display:flex; align-items:center; gap:6px;">
					<span style="font-size:12px; opacity:0.8;">Volumen</span>
					<input id="musicVolume" type="range" min="0" max="1" step="0.01" value="0.35" />
				</label>
			</div>
			<div id="score" style="margin-top:4px;">Cristales: 0 Â· Setas: 0</div>
		</div>
		<div id="hint">AcÃ©rcate a un cristal o seta y pulsa E</div>
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

		<script type="module">
			import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

			const statusEl = document.getElementById('status');
			const scoreEl = document.getElementById('score');
			const hintEl = document.getElementById('hint');

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputColorSpace = THREE.SRGBColorSpace;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1.0;
			document.body.appendChild(renderer.domElement);

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0b0e13);

			// CÃ¡maras: tercera persona y cenital (sobre el personaje)
			const cameraThird = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
			cameraThird.position.set(4, 3, 6);
			const cameraTop = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
			cameraTop.position.set(0, 10, 0);
			let activeCamera = cameraThird;

			// Audio: listener y fuentes
			const audioListener = new THREE.AudioListener();
			activeCamera.add(audioListener);
			const audioLoader = new THREE.AudioLoader();
			const audioFondo = new THREE.Audio(audioListener);
			const sfxRecoger = new THREE.Audio(audioListener);
			const sfxSoltar = new THREE.Audio(audioListener);
			const sfxCaminar = new THREE.Audio(audioListener);
			// Cargar pistas (ajusta extensiÃ³n segÃºn tus archivos)
			audioLoader.load('./assets/sounds/fondo.mp3', (buffer) => {
				audioFondo.setBuffer(buffer);
				audioFondo.setLoop(true);
				audioFondo.setVolume(0.35);
			});
						// UI de mÃºsica: toggle y volumen
						const musicToggle = document.getElementById('musicToggle');
						const musicVolume = document.getElementById('musicVolume');
						let musicEnabled = true;
						musicToggle.addEventListener('click', () => {
							musicEnabled = !musicEnabled;
							if (musicEnabled) {
								musicToggle.textContent = 'ðŸ”Š MÃºsica';
								if (audioFondo.buffer && !audioFondo.isPlaying) audioFondo.play();
							} else {
								musicToggle.textContent = 'ðŸ”‡ MÃºsica';
								if (audioFondo.isPlaying) audioFondo.stop();
							}
						});
						musicVolume.addEventListener('input', (e) => {
							const v = parseFloat(e.target.value);
							audioFondo.setVolume(v);
						});

			audioLoader.load('./assets/sounds/recoger.mp3', (buffer) => {
				sfxRecoger.setBuffer(buffer);
				sfxRecoger.setLoop(false);
				sfxRecoger.setVolume(0.8);
			});
			audioLoader.load('./assets/sounds/soltar.mp3', (buffer) => {
				sfxSoltar.setBuffer(buffer);
				sfxSoltar.setLoop(false);
				sfxSoltar.setVolume(0.8);
			});
			audioLoader.load('./assets/sounds/caminar.mp3', (buffer) => {
				sfxCaminar.setBuffer(buffer);
				sfxCaminar.setLoop(true);
				sfxCaminar.setVolume(0.6);
			});

			// Controles orbit (desactivados por defecto para soporte sin mouse)
			const controls = new OrbitControls(cameraThird, renderer.domElement);
			controls.enableDamping = true;
			controls.target.set(0, 1, 0);
			controls.enabled = false; // laptop sin mouse: usamos teclas

			const hemi = new THREE.HemisphereLight(0xb1e1ff, 0x1b1b1b, 0.6);
			scene.add(hemi);
			const dir = new THREE.DirectionalLight(0xffffff, 1.1);
			dir.position.set(5, 10, 5);
			dir.castShadow = false;
			scene.add(dir);

			const clock = new THREE.Clock();

			// Estado del juego
			const state = {
				loaded: false,
				keys: {},
				speed: 3.0,
				runMultiplier: 1.7,
				carrying: null,
				collected: { cristales: 0, setas: 0 },
				camYawOffset: 0, // ajuste manual de yaw de cÃ¡mara 3Âª persona
				camDistance: 6,  // distancia detrÃ¡s del jugador
				camHeight: 3,    // altura de cÃ¡mara
				turnSmooth: 3,   // suavizado de giro (menor = mÃ¡s suave)
				facingYaw: 0,    // yaw actual suavizado del alquimista
				// FÃ­sica bÃ¡sica
				velocityY: 0,
				gravity: -9.8,
				playerRadius: 0.25,
				groundSnapMax: 0.3,
				walkingSfx: false
			};

			// Objetos clave
			const refs = {
				sceneRoot: null,
				piso: null,
				caldero: null,
				alquimista: null,
				player: new THREE.Group(),
				handAnchor: new THREE.Group(),
				collectibles: [], // { obj, kind: 'cristal'|'seta', taken: false, deposited: false }
				obstacles: []     // { obj, box: Box3 }
			};
			refs.player.name = 'PlayerRoot';
			refs.handAnchor.position.set(0.25, 1.4, 0.35); // offset aproximado frente a la mano
			refs.handAnchor.name = 'HandAnchor';
			refs.player.add(refs.handAnchor);
			scene.add(refs.player);

			// Utilidades
			const tmpVec3 = new THREE.Vector3();
			const tmpBox3 = new THREE.Box3();
			function worldPos(obj) { obj.getWorldPosition(tmpVec3); return tmpVec3.clone(); }
			function distance(a, b) { return a.distanceTo(b); }

			// Carga del GLB exportado desde Blender
			const loader = new GLTFLoader();
			loader.load(
				'./assets/models/esenario.glb',
				(gltf) => {
					refs.sceneRoot = gltf.scene;
					scene.add(gltf.scene);

					// Buscar nodos por nombre (tolerante a mayÃºsculas/minÃºsculas)
					const byName = {};
					gltf.scene.traverse((o) => {
						if (!o.name) return;
						byName[o.name.toLowerCase()] = o;
					});

					// Refs principales
					refs.piso = byName['piso'] || null;
					refs.caldero = byName['caldero'] || null;
					refs.alquimista = byName['alquimista'] || null;

					// Texturizar el piso con terreno.jpg si existe
					if (refs.piso) {
						const texLoader = new THREE.TextureLoader();
						texLoader.load(
							'./assets/textures/terreno.jpg',
							(texture) => {
								texture.colorSpace = THREE.SRGBColorSpace;
								texture.wrapS = THREE.RepeatWrapping;
								texture.wrapT = THREE.RepeatWrapping;
								texture.repeat.set(4, 4);
								// Aplicar material estÃ¡ndar con mapa difuso
								refs.piso.traverse((child) => {
									if (child.isMesh) {
										child.material = new THREE.MeshStandardMaterial({ map: texture });
										child.material.roughness = 1.0;
										child.material.metalness = 0.0;
									}
								});
								statusEl.textContent = 'Textura de terreno aplicada al piso';
							},
							undefined,
							(err) => {
								console.warn('No se pudo cargar la textura terreno.jpg', err);
							}
						);
					}

					if (!refs.alquimista) {
						statusEl.textContent = 'No se encontrÃ³ el objeto "alquimista" en el GLB.';
						console.warn('Objetos disponibles:', Object.keys(byName));
						return;
					}

					// Posicionar el jugador donde estÃ¡ el alquimista, conservando transformaciones
					const startPos = worldPos(refs.alquimista);
					refs.player.position.copy(startPos);
					// Reparent conservando transformaciones mundiales
					refs.player.attach(refs.alquimista);

					// Recolectables: cristales y setas por prefijo
					const isCollectible = (name) => {
						const n = name.toLowerCase();
						if (n.startsWith('cristal')) return 'cristal';
						if (n.startsWith('seta')) return 'seta';
						return null;
					};
					gltf.scene.traverse((o) => {
						if (!o.name) return;
						const kind = isCollectible(o.name);
						if (kind) {
							refs.collectibles.push({ obj: o, kind, taken: false, deposited: false });
						}
					});

					// ObstÃ¡culos: Ã¡rboles y caldero para colisiÃ³n simple (AABB)
					const isObstacle = (name) => {
						const n = name.toLowerCase();
						if (n.startsWith('arbol')) return true;
						if (n === 'caldero') return true;
						return false;
					};
					gltf.scene.traverse((o) => {
						if (!o.name) return;
						if (isObstacle(o.name)) {
							const box = new THREE.Box3().setFromObject(o);
							// Ajuste Ãºnico: encoger ligeramente el AABB para evitar sobrebloqueo
							box.expandByScalar(-0.05);
							refs.obstacles.push({ obj: o, box });
						}
					});

					// FunciÃ³n para resolver solapamiento inicial del spawn con obstÃ¡culos
					function resolveSpawnOverlap() {
						if (!refs.obstacles.length) return;
						const pos = refs.player.position.clone();
						for (const ob of refs.obstacles) {
							const minX = ob.box.min.x - state.playerRadius;
							const maxX = ob.box.max.x + state.playerRadius;
							const minZ = ob.box.min.z - state.playerRadius;
							const maxZ = ob.box.max.z + state.playerRadius;
							if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
								const center = new THREE.Vector3(
									(ob.box.min.x + ob.box.max.x) * 0.5,
									0,
									(ob.box.min.z + ob.box.max.z) * 0.5
								);
								const dir = new THREE.Vector3().subVectors(pos, center);
								if (dir.lengthSq() === 0) dir.set(1, 0, 0);
								dir.normalize().multiplyScalar(state.playerRadius + 0.3);
								refs.player.position.add(dir);
							}
						}
					}

					// Ajustar cÃ¡maras a la posiciÃ³n inicial del jugador
					controls.target.copy(refs.player.position).add(new THREE.Vector3(0, 1.2, 0));
					cameraThird.position.copy(refs.player.position).add(new THREE.Vector3(4, 3, 6));
					cameraThird.lookAt(controls.target);
					cameraTop.position.copy(refs.player.position).add(new THREE.Vector3(0, 10, 0));
					cameraTop.lookAt(new THREE.Vector3().copy(refs.player.position));
					controls.update();

					// Empujar fuera si el spawn cayÃ³ dentro de algÃºn obstÃ¡culo
					resolveSpawnOverlap();

					state.loaded = true;
					statusEl.textContent = 'Listo: mueve al alquimista y recoge ingredientes';
				},
				(xhr) => {
					const t = xhr.total || 1;
					const pct = Math.round((xhr.loaded / t) * 100);
					statusEl.textContent = `Cargando escenarioâ€¦ ${pct}%`;
				},
				(err) => {
					console.error(err);
					statusEl.textContent = 'Error cargando el escenario (.glb)';
				}
			);

			// Entradas teclado
			window.addEventListener('keydown', (e) => {
				state.keys[e.code] = true;
				// Evitar scroll con WASD/Space
				if (["KeyW","KeyA","KeyS","KeyD","Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
					e.preventDefault();
				}
				if (e.code === 'KeyE') tryPickup();
				if (e.code === 'KeyF') tryDrop();
				if (e.code === 'KeyC') toggleCamera();
				// Desbloquear/arrancar mÃºsica de fondo tras primera interacciÃ³n
				if (!audioFondo.isPlaying && audioFondo.buffer) {
					audioFondo.play();
				}
				// Ajustes de cÃ¡mara para laptops sin mouse
				// Controles de cÃ¡mara con letras (sin corchetes ni signos)
				if (e.code === 'KeyJ') state.camYawOffset -= 0.1;      // girar cÃ¡mara a la izquierda
				if (e.code === 'KeyK') state.camYawOffset += 0.1;      // girar cÃ¡mara a la derecha
				if (e.code === 'KeyU') state.camDistance = Math.min(12, Math.max(2, state.camDistance + 0.5)); // alejar
				if (e.code === 'KeyI') state.camDistance = Math.min(12, Math.max(2, state.camDistance - 0.5)); // acercar
			});
						function updateCameras() {
							// Tercera persona: seguir y mirar al jugador
							if (activeCamera === cameraThird) {
								const target = new THREE.Vector3().copy(refs.player.position).add(new THREE.Vector3(0, 1.2, 0));
								controls.target.copy(target);
								// Mantener cÃ¡mara detrÃ¡s del alquimista segÃºn su orientaciÃ³n, con offset manual
								const yaw = (refs.alquimista ? refs.alquimista.rotation.y : 0) + state.camYawOffset;
								const back = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(-state.camDistance);
								const camPos = new THREE.Vector3().copy(refs.player.position).add(back).add(new THREE.Vector3(0, state.camHeight, 0));
								cameraThird.position.lerp(camPos, 0.25);
								cameraThird.lookAt(target);
							}
							// Cenital: directamente encima del jugador
							if (activeCamera === cameraTop) {
								cameraTop.position.copy(refs.player.position).add(new THREE.Vector3(0, 10, 0));
								cameraTop.lookAt(new THREE.Vector3().copy(refs.player.position));
							}
						}

						function toggleCamera() {
							activeCamera = (activeCamera === cameraThird) ? cameraTop : cameraThird;
							const useControls = (activeCamera === cameraThird);
							controls.enabled = useControls;
							// Mantener el listener en la cÃ¡mara activa
							cameraThird.remove(audioListener);
							cameraTop.remove(audioListener);
							activeCamera.add(audioListener);
							hint(useControls ? 'CÃ¡mara tercera persona' : 'CÃ¡mara cenital');
						}
			window.addEventListener('keyup', (e) => { state.keys[e.code] = false; });

			function movePlayer(dt) {
				if (!state.loaded) return;
				const speed = state.speed * (state.keys['ShiftLeft'] || state.keys['ShiftRight'] ? state.runMultiplier : 1.0);

				// DirecciÃ³n relativa a la cÃ¡mara activa (para WASD)
				const camForward = new THREE.Vector3();
				activeCamera.getWorldDirection(camForward);
				camForward.y = 0; camForward.normalize();
				const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).negate();

				// DirecciÃ³n relativa al personaje (para flechas)
				const yaw = state.facingYaw;
				const chrForward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
				const chrRight = new THREE.Vector3().crossVectors(chrForward, new THREE.Vector3(0,1,0));

				const dir = new THREE.Vector3();
				// WASD: relativo a la cÃ¡mara
				if (state.keys['KeyW']) dir.add(camForward);
				if (state.keys['KeyS']) dir.sub(camForward);
				if (state.keys['KeyA']) dir.sub(camRight);
				if (state.keys['KeyD']) dir.add(camRight);
				// Flechas: relativo al personaje
				if (state.keys['ArrowUp']) dir.add(chrForward);
				if (state.keys['ArrowDown']) dir.sub(chrForward);
				if (state.keys['ArrowLeft']) dir.sub(chrRight);
				if (state.keys['ArrowRight']) dir.add(chrRight);
				const movingWithArrows = state.keys['ArrowUp'] || state.keys['ArrowDown'] || state.keys['ArrowLeft'] || state.keys['ArrowRight'];
				if (dir.lengthSq() > 0) {
					dir.normalize().multiplyScalar(speed * dt);
					// Intentar mover y evitar colisiones con obstÃ¡culos (AABB)
					const nextPos = new THREE.Vector3().copy(refs.player.position).add(dir);
					if (!collides(nextPos)) {
						refs.player.position.copy(nextPos);
					} else {
						// intento simple de deslizamiento: probar sÃ³lo X y sÃ³lo Z
						const tryX = new THREE.Vector3(refs.player.position.x + dir.x, refs.player.position.y, refs.player.position.z);
						if (!collides(tryX)) refs.player.position.copy(tryX);
						const tryZ = new THREE.Vector3(refs.player.position.x, refs.player.position.y, refs.player.position.z + dir.z);
						if (!collides(tryZ)) refs.player.position.copy(tryZ);
					}
					// Orientar el alquimista hacia el movimiento con suavizado
					const targetYaw = Math.atan2(dir.x, dir.z);
					// suavizado: mover facingYaw hacia targetYaw
					const angleDelta = ((targetYaw - state.facingYaw + Math.PI) % (2 * Math.PI)) - Math.PI;
					state.facingYaw += angleDelta * Math.min(1, state.turnSmooth * dt);
					refs.alquimista.rotation.y = state.facingYaw;

					// SFX caminar: sÃ³lo cuando se usan flechas
					if (movingWithArrows && sfxCaminar.buffer && !state.walkingSfx) {
						sfxCaminar.play();
						state.walkingSfx = true;
					}
				}
				else {
					// Parar SFX caminar al detenerse
					if (state.walkingSfx && sfxCaminar.isPlaying) {
						sfxCaminar.stop();
					}
					state.walkingSfx = false;
				}

				// FÃ­sica: gravedad + ajuste al piso mediante raycast
				applyGravityAndGround(dt);

				// Mantener la cÃ¡mara siguiendo al jugador
				const target = new THREE.Vector3().copy(refs.player.position).add(new THREE.Vector3(0, 1.2, 0));
				controls.target.copy(target);
			}

			const raycaster = new THREE.Raycaster();
			function applyGravityAndGround(dt) {
				if (!refs.piso) return;
				// Raycast hacia abajo desde la posiciÃ³n del jugador
				raycaster.set(new THREE.Vector3(refs.player.position.x, refs.player.position.y + 1, refs.player.position.z), new THREE.Vector3(0, -1, 0));
				const intersects = raycaster.intersectObject(refs.piso, true);
				if (intersects.length > 0) {
					const hitY = intersects[0].point.y;
					const deltaY = refs.player.position.y - hitY;
					if (deltaY <= state.groundSnapMax) {
						// En el suelo: pegar al piso y resetear gravedad
						refs.player.position.y = hitY;
						state.velocityY = 0;
						return;
					}
				}
				// En el aire: aplicar gravedad
				state.velocityY += state.gravity * dt;
				refs.player.position.y += state.velocityY * dt;
			}

			function collides(testPos) {
							// ColisiÃ³n 2D (XZ) tipo cÃ­rculo vs AABB
							const r = state.playerRadius;
							for (const ob of refs.obstacles) {
								const minX = ob.box.min.x - r;
								const maxX = ob.box.max.x + r;
								const minZ = ob.box.min.z - r;
								const maxZ = ob.box.max.z + r;
								if (testPos.x >= minX && testPos.x <= maxX && testPos.z >= minZ && testPos.z <= maxZ) {
									return true;
								}
							}
							return false;

			function resolveSpawnOverlap() {
				if (!refs.obstacles.length) return;
				const pos = refs.player.position.clone();
				for (const ob of refs.obstacles) {
					const minX = ob.box.min.x - state.playerRadius;
					const maxX = ob.box.max.x + state.playerRadius;
					const minZ = ob.box.min.z - state.playerRadius;
					const maxZ = ob.box.max.z + state.playerRadius;
					if (pos.x >= minX && pos.x <= maxX && pos.z >= minZ && pos.z <= maxZ) {
						// Empujar hacia afuera en direcciÃ³n desde el centro del obstÃ¡culo
						const center = new THREE.Vector3(
							(ob.box.min.x + ob.box.max.x) * 0.5,
							0,
							(ob.box.min.z + ob.box.max.z) * 0.5
						);
						const dir = new THREE.Vector3().subVectors(pos, center);
						if (dir.lengthSq() === 0) dir.set(1, 0, 0);
						dir.normalize().multiplyScalar(state.playerRadius + 0.3);
						refs.player.position.add(dir);
					}
				}
			}
			}

			function nearestCollectible(maxDist = 1.5) {
				if (!refs.collectibles.length) return null;
				const p = worldPos(refs.player);
				let best = null; let bestD = Infinity;
				for (const c of refs.collectibles) {
					if (c.taken || c.deposited) continue;
					const d = distance(worldPos(c.obj), p);
					if (d < bestD && d <= maxDist) { bestD = d; best = c; }
				}
				return best;
			}

			function tryPickup() {
				if (!state.loaded || state.carrying) return;
				const c = nearestCollectible();
				if (!c) { hint('No hay objetos cercanos'); return; }
				// Adjuntar al ancla de mano conservando posiciÃ³n relativa actual
				refs.handAnchor.attach(c.obj);
				c.taken = true;
				state.carrying = c;
				if (sfxRecoger.buffer) sfxRecoger.play();
				hint(`Recogido ${c.kind}`);
			}

			function tryDrop() {
				if (!state.loaded || !state.carrying) { hint('No llevas nada'); return; }
				if (!refs.caldero) { hint('No hay caldero en la escena'); return; }
				const pPlayer = worldPos(refs.player);
				const pCaldero = worldPos(refs.caldero);
				const d = distance(pPlayer, pCaldero);
				if (d > 2.2) { hint('AcÃ©rcate al caldero para soltar'); return; }

				// Soltar en el caldero: re-parent a la escena y posicionar sobre el caldero
				const obj = state.carrying.obj;
				scene.attach(obj);
				// Calcular un punto de caÃ­da encima del caldero
				tmpBox3.setFromObject(refs.caldero);
				const dropX = pCaldero.x + (Math.random() - 0.5) * 0.4;
				const dropZ = pCaldero.z + (Math.random() - 0.5) * 0.4;
				const dropY = tmpBox3.max.y + 0.15;
				obj.position.set(dropX, dropY, dropZ);
				state.carrying.deposited = true;
				// Actualizar marcador
				if (state.carrying.kind === 'cristal') state.collected.cristales += 1;
				if (state.carrying.kind === 'seta') state.collected.setas += 1;
				scoreEl.textContent = `Cristales: ${state.collected.cristales} Â· Setas: ${state.collected.setas}`;
				if (sfxSoltar.buffer) sfxSoltar.play();
				hint(`Depositado ${state.carrying.kind} en el caldero`);
				state.carrying = null;
			}

			let hintTimeout = null;
			function hint(msg) {
				clearTimeout(hintTimeout);
				hintEl.textContent = msg;
				hintEl.style.opacity = '1';
				hintTimeout = setTimeout(() => { hintEl.style.opacity = '0.85'; }, 1500);
			}

			function animate() {
				const dt = clock.getDelta();
				movePlayer(dt);
				updateCameras();
				controls.update();
				renderer.render(scene, activeCamera);
				requestAnimationFrame(animate);
			}
			animate();

			window.addEventListener('resize', () => {
				cameraThird.aspect = window.innerWidth / window.innerHeight;
				cameraThird.updateProjectionMatrix();
				cameraTop.aspect = window.innerWidth / window.innerHeight;
				cameraTop.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		</script>
	</body>
	</html>

