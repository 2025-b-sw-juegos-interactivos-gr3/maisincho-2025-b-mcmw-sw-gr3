<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:,">
		<title>Proyecto Alquimista</title>
		<style>
			html, body {
				margin: 0;
				height: 100%;
				overflow: hidden;
				background: #0b0e13;
				color: #e6e6e6;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
			}
			#ui {
				position: fixed;
				top: 12px;
				left: 12px;
				background: rgba(0, 0, 0, 0.45);
				backdrop-filter: blur(4px);
				border: 1px solid rgba(255, 255, 255, 0.12);
				padding: 10px 12px;
				border-radius: 10px;
				line-height: 1.35;
				z-index: 10;
				user-select: none;
			}
			#ui b { color: #79ffe1; }
			#hint {
				position: fixed;
				bottom: 12px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.5);
				padding: 8px 12px;
				border-radius: 8px;
				font-size: 14px;
				border: 1px solid rgba(255,255,255,0.1);
			}
			canvas { display: block; }
		</style>
	</head>
	<body>
		<div id="ui">
			<div><b>Movimiento:</b> W/A/S/D o Flechas · Shift para correr</div>
			<div><b>Cámara 3ª persona:</b> J/K girar cámara · U/I zoom</div>
			<div><b>Cámara cenital:</b> Tecla C para alternar</div>
			<div><b>Acciones:</b> E recoger (cerca de cristal/seta) · F soltar en el caldero</div>
			<div><b>Consejos:</b> Acércate a los objetos (~1.5m) y al caldero (~2.2m)</div>
			<div id="status">Cargando escenario…</div>
			<div id="score" style="margin-top:4px;">Cristales: 0 · Setas: 0</div>
		</div>
		<div id="hint">Acércate a un cristal o seta y pulsa E</div>
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

		<script type="module">
			import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

			const statusEl = document.getElementById('status');
			const scoreEl = document.getElementById('score');
			const hintEl = document.getElementById('hint');

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputColorSpace = THREE.SRGBColorSpace;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1.0;
			document.body.appendChild(renderer.domElement);

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0b0e13);

			// Cámaras: tercera persona y cenital (sobre el personaje)
			const cameraThird = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
			cameraThird.position.set(4, 3, 6);
			const cameraTop = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
			cameraTop.position.set(0, 10, 0);
			let activeCamera = cameraThird;

			// Controles orbit (desactivados por defecto para soporte sin mouse)
			const controls = new OrbitControls(cameraThird, renderer.domElement);
			controls.enableDamping = true;
			controls.target.set(0, 1, 0);
			controls.enabled = false; // laptop sin mouse: usamos teclas

			const hemi = new THREE.HemisphereLight(0xb1e1ff, 0x1b1b1b, 0.6);
			scene.add(hemi);
			const dir = new THREE.DirectionalLight(0xffffff, 1.1);
			dir.position.set(5, 10, 5);
			dir.castShadow = false;
			scene.add(dir);

			const clock = new THREE.Clock();

			// Estado del juego
			const state = {
				loaded: false,
				keys: {},
				speed: 3.0,
				runMultiplier: 1.7,
				carrying: null,
				collected: { cristales: 0, setas: 0 },
				camYawOffset: 0, // ajuste manual de yaw de cámara 3ª persona
				camDistance: 6,  // distancia detrás del jugador
				camHeight: 3,    // altura de cámara
				turnSmooth: 3,   // suavizado de giro (menor = más suave)
				facingYaw: 0     // yaw actual suavizado del alquimista
			};

			// Objetos clave
			const refs = {
				sceneRoot: null,
				piso: null,
				caldero: null,
				alquimista: null,
				player: new THREE.Group(),
				handAnchor: new THREE.Group(),
				collectibles: [], // { obj, kind: 'cristal'|'seta', taken: false, deposited: false }
			};
			refs.player.name = 'PlayerRoot';
			refs.handAnchor.position.set(0.25, 1.4, 0.35); // offset aproximado frente a la mano
			refs.handAnchor.name = 'HandAnchor';
			refs.player.add(refs.handAnchor);
			scene.add(refs.player);

			// Utilidades
			const tmpVec3 = new THREE.Vector3();
			const tmpBox3 = new THREE.Box3();
			function worldPos(obj) { obj.getWorldPosition(tmpVec3); return tmpVec3.clone(); }
			function distance(a, b) { return a.distanceTo(b); }

			// Carga del GLB exportado desde Blender
			const loader = new GLTFLoader();
			loader.load(
				'./assets/models/esenario.glb',
				(gltf) => {
					refs.sceneRoot = gltf.scene;
					scene.add(gltf.scene);

					// Buscar nodos por nombre (tolerante a mayúsculas/minúsculas)
					const byName = {};
					gltf.scene.traverse((o) => {
						if (!o.name) return;
						byName[o.name.toLowerCase()] = o;
					});

					// Refs principales
					refs.piso = byName['piso'] || null;
					refs.caldero = byName['caldero'] || null;
					refs.alquimista = byName['alquimista'] || null;

					// Texturizar el piso con terreno.jpg si existe
					if (refs.piso) {
						const texLoader = new THREE.TextureLoader();
						texLoader.load(
							'./assets/textures/terreno.jpg',
							(texture) => {
								texture.colorSpace = THREE.SRGBColorSpace;
								texture.wrapS = THREE.RepeatWrapping;
								texture.wrapT = THREE.RepeatWrapping;
								texture.repeat.set(4, 4);
								// Aplicar material estándar con mapa difuso
								refs.piso.traverse((child) => {
									if (child.isMesh) {
										child.material = new THREE.MeshStandardMaterial({ map: texture });
										child.material.roughness = 1.0;
										child.material.metalness = 0.0;
									}
								});
								statusEl.textContent = 'Textura de terreno aplicada al piso';
							},
							undefined,
							(err) => {
								console.warn('No se pudo cargar la textura terreno.jpg', err);
							}
						);
					}

					if (!refs.alquimista) {
						statusEl.textContent = 'No se encontró el objeto "alquimista" en el GLB.';
						console.warn('Objetos disponibles:', Object.keys(byName));
						return;
					}

					// Posicionar el jugador donde está el alquimista, conservando transformaciones
					const startPos = worldPos(refs.alquimista);
					refs.player.position.copy(startPos);
					// Reparent conservando transformaciones mundiales
					refs.player.attach(refs.alquimista);

					// Recolectables: cristales y setas por prefijo
					const isCollectible = (name) => {
						const n = name.toLowerCase();
						if (n.startsWith('cristal')) return 'cristal';
						if (n.startsWith('seta')) return 'seta';
						return null;
					};
					gltf.scene.traverse((o) => {
						if (!o.name) return;
						const kind = isCollectible(o.name);
						if (kind) {
							refs.collectibles.push({ obj: o, kind, taken: false, deposited: false });
						}
					});

					// Ajustar cámaras a la posición inicial del jugador
					controls.target.copy(refs.player.position).add(new THREE.Vector3(0, 1.2, 0));
					cameraThird.position.copy(refs.player.position).add(new THREE.Vector3(4, 3, 6));
					cameraThird.lookAt(controls.target);
					cameraTop.position.copy(refs.player.position).add(new THREE.Vector3(0, 10, 0));
					cameraTop.lookAt(new THREE.Vector3().copy(refs.player.position));
					controls.update();

					state.loaded = true;
					statusEl.textContent = 'Listo: mueve al alquimista y recoge ingredientes';
				},
				(xhr) => {
					const t = xhr.total || 1;
					const pct = Math.round((xhr.loaded / t) * 100);
					statusEl.textContent = `Cargando escenario… ${pct}%`;
				},
				(err) => {
					console.error(err);
					statusEl.textContent = 'Error cargando el escenario (.glb)';
				}
			);

			// Entradas teclado
			window.addEventListener('keydown', (e) => {
				state.keys[e.code] = true;
				// Evitar scroll con WASD/Space
				if (["KeyW","KeyA","KeyS","KeyD","Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
					e.preventDefault();
				}
				if (e.code === 'KeyE') tryPickup();
				if (e.code === 'KeyF') tryDrop();
				if (e.code === 'KeyC') toggleCamera();
				// Ajustes de cámara para laptops sin mouse
				// Controles de cámara con letras (sin corchetes ni signos)
				if (e.code === 'KeyJ') state.camYawOffset -= 0.1;      // girar cámara a la izquierda
				if (e.code === 'KeyK') state.camYawOffset += 0.1;      // girar cámara a la derecha
				if (e.code === 'KeyU') state.camDistance = Math.min(12, Math.max(2, state.camDistance + 0.5)); // alejar
				if (e.code === 'KeyI') state.camDistance = Math.min(12, Math.max(2, state.camDistance - 0.5)); // acercar
			});
						function updateCameras() {
							// Tercera persona: seguir y mirar al jugador
							if (activeCamera === cameraThird) {
								const target = new THREE.Vector3().copy(refs.player.position).add(new THREE.Vector3(0, 1.2, 0));
								controls.target.copy(target);
								// Mantener cámara detrás del alquimista según su orientación, con offset manual
								const yaw = (refs.alquimista ? refs.alquimista.rotation.y : 0) + state.camYawOffset;
								const back = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(-state.camDistance);
								const camPos = new THREE.Vector3().copy(refs.player.position).add(back).add(new THREE.Vector3(0, state.camHeight, 0));
								cameraThird.position.lerp(camPos, 0.25);
								cameraThird.lookAt(target);
							}
							// Cenital: directamente encima del jugador
							if (activeCamera === cameraTop) {
								cameraTop.position.copy(refs.player.position).add(new THREE.Vector3(0, 10, 0));
								cameraTop.lookAt(new THREE.Vector3().copy(refs.player.position));
							}
						}

						function toggleCamera() {
							activeCamera = (activeCamera === cameraThird) ? cameraTop : cameraThird;
							const useControls = (activeCamera === cameraThird);
							controls.enabled = useControls;
							hint(useControls ? 'Cámara tercera persona' : 'Cámara cenital');
						}
			window.addEventListener('keyup', (e) => { state.keys[e.code] = false; });

			function movePlayer(dt) {
				if (!state.loaded) return;
				const speed = state.speed * (state.keys['ShiftLeft'] || state.keys['ShiftRight'] ? state.runMultiplier : 1.0);

				// Dirección relativa a la cámara activa (para WASD)
				const camForward = new THREE.Vector3();
				activeCamera.getWorldDirection(camForward);
				camForward.y = 0; camForward.normalize();
				const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).negate();

				// Dirección relativa al personaje (para flechas)
				const yaw = state.facingYaw;
				const chrForward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
				const chrRight = new THREE.Vector3().crossVectors(chrForward, new THREE.Vector3(0,1,0));

				const dir = new THREE.Vector3();
				// WASD: relativo a la cámara
				if (state.keys['KeyW']) dir.add(camForward);
				if (state.keys['KeyS']) dir.sub(camForward);
				if (state.keys['KeyA']) dir.sub(camRight);
				if (state.keys['KeyD']) dir.add(camRight);
				// Flechas: relativo al personaje
				if (state.keys['ArrowUp']) dir.add(chrForward);
				if (state.keys['ArrowDown']) dir.sub(chrForward);
				if (state.keys['ArrowLeft']) dir.sub(chrRight);
				if (state.keys['ArrowRight']) dir.add(chrRight);
				if (dir.lengthSq() > 0) {
					dir.normalize().multiplyScalar(speed * dt);
					refs.player.position.add(dir);
					// Orientar el alquimista hacia el movimiento con suavizado
					const targetYaw = Math.atan2(dir.x, dir.z);
					// suavizado: mover facingYaw hacia targetYaw
					const angleDelta = ((targetYaw - state.facingYaw + Math.PI) % (2 * Math.PI)) - Math.PI;
					state.facingYaw += angleDelta * Math.min(1, state.turnSmooth * dt);
					refs.alquimista.rotation.y = state.facingYaw;
				}

				// Mantener la cámara siguiendo al jugador
				const target = new THREE.Vector3().copy(refs.player.position).add(new THREE.Vector3(0, 1.2, 0));
				controls.target.copy(target);
			}

			function nearestCollectible(maxDist = 1.5) {
				if (!refs.collectibles.length) return null;
				const p = worldPos(refs.player);
				let best = null; let bestD = Infinity;
				for (const c of refs.collectibles) {
					if (c.taken || c.deposited) continue;
					const d = distance(worldPos(c.obj), p);
					if (d < bestD && d <= maxDist) { bestD = d; best = c; }
				}
				return best;
			}

			function tryPickup() {
				if (!state.loaded || state.carrying) return;
				const c = nearestCollectible();
				if (!c) { hint('No hay objetos cercanos'); return; }
				// Adjuntar al ancla de mano conservando posición relativa actual
				refs.handAnchor.attach(c.obj);
				c.taken = true;
				state.carrying = c;
				hint(`Recogido ${c.kind}`);
			}

			function tryDrop() {
				if (!state.loaded || !state.carrying) { hint('No llevas nada'); return; }
				if (!refs.caldero) { hint('No hay caldero en la escena'); return; }
				const pPlayer = worldPos(refs.player);
				const pCaldero = worldPos(refs.caldero);
				const d = distance(pPlayer, pCaldero);
				if (d > 2.2) { hint('Acércate al caldero para soltar'); return; }

				// Soltar en el caldero: re-parent a la escena y posicionar sobre el caldero
				const obj = state.carrying.obj;
				scene.attach(obj);
				// Calcular un punto de caída encima del caldero
				tmpBox3.setFromObject(refs.caldero);
				const dropX = pCaldero.x + (Math.random() - 0.5) * 0.4;
				const dropZ = pCaldero.z + (Math.random() - 0.5) * 0.4;
				const dropY = tmpBox3.max.y + 0.15;
				obj.position.set(dropX, dropY, dropZ);
				state.carrying.deposited = true;
				// Actualizar marcador
				if (state.carrying.kind === 'cristal') state.collected.cristales += 1;
				if (state.carrying.kind === 'seta') state.collected.setas += 1;
				scoreEl.textContent = `Cristales: ${state.collected.cristales} · Setas: ${state.collected.setas}`;
				hint(`Depositado ${state.carrying.kind} en el caldero`);
				state.carrying = null;
			}

			let hintTimeout = null;
			function hint(msg) {
				clearTimeout(hintTimeout);
				hintEl.textContent = msg;
				hintEl.style.opacity = '1';
				hintTimeout = setTimeout(() => { hintEl.style.opacity = '0.85'; }, 1500);
			}

			function animate() {
				const dt = clock.getDelta();
				movePlayer(dt);
				updateCameras();
				controls.update();
				renderer.render(scene, activeCamera);
				requestAnimationFrame(animate);
			}
			animate();

			window.addEventListener('resize', () => {
				cameraThird.aspect = window.innerWidth / window.innerHeight;
				cameraThird.updateProjectionMatrix();
				cameraTop.aspect = window.innerWidth / window.innerHeight;
				cameraTop.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		</script>
	</body>
	</html>

